plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

// Workaround für Shadow Plugin Kompatibilität mit Gradle 8.10+
shadowJar {
    archiveBaseName.set("itp-app")
    archiveVersion.set("1.0")
    archiveClassifier.set("")
    manifest {
        attributes 'Main-Class': 'at.tgm.Main'
    }
    // Vermeide Probleme mit META-INF Verzeichnissen
    mergeServiceFiles()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

group 'at.tgm'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

// Konfiguriere das normale JAR mit Main-Class
jar {
    manifest {
        attributes 'Main-Class': 'at.tgm.Main'
    }
}
dependencies {
    implementation 'com.esotericsoftware:kryo:5.5.0'

    // funktionierendes Serializer-Paket
    implementation 'de.javakaffee:kryo-serializers:0.45'

    implementation 'org.lz4:lz4-java:1.8.0'

    // Logging
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation 'ch.qos.logback:logback-classic:1.4.11'

    // Database
    implementation 'com.mysql:mysql-connector-j:8.3.0'
    implementation 'com.zaxxer:HikariCP:5.1.0'

    // Password Hashing
    implementation 'org.mindrot:jbcrypt:0.4'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
}


test {
    useJUnitPlatform()
    
    // Show test output in console
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = true
    }
    
    // Ensure tests have enough time (for integration tests)  
    // Note: Individual test timeouts are handled via @Timeout annotation in test classes
    
    // Run tests even if there are test failures
    ignoreFailures = false
    
    // Fork JVM for tests to avoid conflicts
    forkEvery = 1
}

// Helper task to print classpath (for debugging)
task printClasspath {
    doLast {
        println sourceSets.main.runtimeClasspath.asPath
    }
}

// Task zum Starten des Clients
task runClient(type: JavaExec) {
    group = 'application'
    description = 'Startet den Client'
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'at.tgm.Main'
    args = ['client']
}

// Task zum Starten des Servers
task runServer(type: JavaExec) {
    group = 'application'
    description = 'Startet den Server'
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'at.tgm.server.Server'
}

// ============================================
// Native Installer Builds (jpackage)
// ============================================

def appName = 'FachbegriffeTrainer'
def appVersion = '1.0'
def vendor = 'TGM'
def mainClass = 'at.tgm.Main'
def iconPng = file("${projectDir}/src/main/resources/icon.png")
def iconIcons = file("${buildDir}/resources/icon.icns")
def iconIco = file("${buildDir}/resources/icon.ico")

// Task zum Konvertieren des Icons zu .icns für macOS
task convertIconToIcons {
    group = 'distribution'
    description = 'Konvertiert PNG Icon zu .icns für macOS'
    
    doFirst {
        if (!iconPng.exists()) {
            throw new GradleException("Icon nicht gefunden: ${iconPng}")
        }
        
        // Erstelle .icns aus PNG mit sips (macOS Tool)
        def iconsetDir = file("${buildDir}/resources/icon.iconset")
        iconsetDir.mkdirs()
        
        // Erstelle verschiedene Größen für .icns
        def sizes = [16, 32, 64, 128, 256, 512, 1024]
        sizes.each { size ->
            def outputFile = file("${iconsetDir}/icon_${size}x${size}.png")
            project.exec {
                commandLine 'sips', '-z', size.toString(), size.toString(), iconPng, '--out', outputFile
                ignoreExitValue = false
            }
            
            // Für Retina-Displays
            if (size <= 512) {
                def retinaSize = size * 2
                def retinaFile = file("${iconsetDir}/icon_${size}x${size}@2x.png")
                project.exec {
                    commandLine 'sips', '-z', retinaSize.toString(), retinaSize.toString(), iconPng, '--out', retinaFile
                    ignoreExitValue = false
                }
            }
        }
        
        // Konvertiere iconset zu .icns
        project.exec {
            commandLine 'iconutil', '-c', 'icns', iconsetDir, '-o', iconIcons
            ignoreExitValue = false
        }
        
        // Lösche temporäres iconset-Verzeichnis
        delete iconsetDir
    }
    
    outputs.file(iconIcons)
}

// Task zum Erstellen eines .dmg Installers für macOS
task buildDmg(type: Exec) {
    group = 'distribution'
    description = 'Erstellt einen .dmg Installer für macOS'
    
    dependsOn shadowJar, convertIconToIcons
    
    executable = 'jpackage'
    
    doFirst {
        // Prüfe ob wir auf macOS sind
        if (!System.getProperty('os.name').toLowerCase().contains('mac')) {
            throw new GradleException('buildDmg kann nur auf macOS ausgeführt werden')
        }
        
        // Lösche vorherige Builds
        delete fileTree("${buildDir}/distributions") {
            include "*.dmg"
        }
        
        def mainJar = shadowJar.archiveFileName.get()
        def iconArg = iconIcons.exists() ? iconIcons.absolutePath : iconPng.absolutePath
        
        args = [
            '--input', "${buildDir}/libs",
            '--name', appName,
            '--main-jar', mainJar,
            '--main-class', mainClass,
            '--app-version', appVersion,
            '--vendor', vendor,
            '--dest', "${buildDir}/distributions",
            '--type', 'dmg',
            '--icon', iconArg,
            '--java-options', '--add-opens=java.base/java.lang=ALL-UNNAMED',
            '--java-options', '--add-opens=java.base/java.util=ALL-UNNAMED',
            '--arguments', 'client'
        ]
    }
    
    doLast {
        println "✅ .dmg Installer erstellt in: ${buildDir}/distributions/"
    }
}

// Task zum Konvertieren des Icons zu .ico für Windows
task convertIconToIco {
    group = 'distribution'
    description = 'Konvertiert PNG Icon zu .ico für Windows'
    
    doFirst {
        if (!iconPng.exists()) {
            throw new GradleException("Icon nicht gefunden: ${iconPng}")
        }
        
        // Stelle sicher, dass das Ausgabeverzeichnis existiert
        iconIco.parentFile.mkdirs()
        
        // Versuche ImageMagick zu verwenden (funktioniert auf Windows, macOS und Linux)
        def conversionSuccess = false
        try {
            def result = project.exec {
                commandLine 'magick', iconPng, '-define', 'icon:auto-resize=256,128,64,48,32,16', iconIco
                ignoreExitValue = true
            }
            if (result.exitValue == 0) {
                conversionSuccess = true
            }
        } catch (Exception e) {
            // ImageMagick nicht verfügbar oder Fehler beim Ausführen
        }
        
        if (!conversionSuccess) {
            // Warnung: Ohne ImageMagick können wir kein echtes ICO erstellen
            // jpackage auf Windows benötigt ein echtes ICO-Format
            println "⚠️  WARNUNG: ImageMagick nicht gefunden oder Konvertierung fehlgeschlagen!"
            println "   Bitte installieren Sie ImageMagick von https://imagemagick.org/"
            println "   oder verwenden Sie ein bereits vorhandenes .ico Icon."
            println "   jpackage wird ohne Icon fortfahren (oder mit PNG, falls unterstützt)."
            // Keine Datei erstellen - die Build-Tasks werden dann ohne Icon-Argument fortfahren
        }
    }
    
    outputs.file(iconIco)
}

// Task zum Erstellen eines portablen App-Images für Windows (kein WiX benötigt)
task buildExeAppImage(type: Exec) {
    group = 'distribution'
    description = 'Erstellt ein portables App-Image für Windows (kein WiX benötigt)'
    
    dependsOn shadowJar, convertIconToIco
    
    executable = 'jpackage'
    
    doFirst {
        // Prüfe ob wir auf Windows sind
        if (!System.getProperty('os.name').toLowerCase().contains('windows')) {
            throw new GradleException('buildExeAppImage kann nur auf Windows ausgeführt werden.')
        }
        
        // Lösche vorherige Builds
        delete fileTree("${buildDir}/distributions") {
            include "${appName}*"
        }
        
        def mainJar = shadowJar.archiveFileName.get()
        
        // Nur Icon verwenden, wenn es existiert und nicht leer ist (echtes ICO)
        def argsList = [
            '--input', "${buildDir}/libs",
            '--name', appName,
            '--main-jar', mainJar,
            '--main-class', mainClass,
            '--app-version', appVersion,
            '--vendor', vendor,
            '--dest', "${buildDir}/distributions",
            '--type', 'app-image',
            '--java-options', '--add-opens=java.base/java.lang=ALL-UNNAMED',
            '--java-options', '--add-opens=java.base/java.util=ALL-UNNAMED',
            '--arguments', 'client'
        ]
        
        // Füge Icon nur hinzu, wenn es ein gültiges ICO ist (nicht leer)
        if (iconIco.exists() && iconIco.length() > 0) {
            argsList.addAll(['--icon', iconIco.absolutePath])
        } else if (iconPng.exists()) {
            // Fallback: Versuche PNG (jpackage kann es manchmal akzeptieren)
            println "⚠️  Verwende PNG als Icon (ICO-Konvertierung fehlgeschlagen)"
            argsList.addAll(['--icon', iconPng.absolutePath])
        }
        
        args = argsList
    }
    
    doLast {
        println "✅ App-Image erstellt in: ${buildDir}/distributions/${appName}/"
    }
}

// Task zum Erstellen eines ZIP-Archivs für Windows (kein WiX benötigt)
task buildExe(type: Zip) {
    group = 'distribution'
    description = 'Erstellt ein ZIP-Archiv für Windows (kein WiX benötigt)'
    
    dependsOn buildExeAppImage
    
    archiveBaseName = appName
    archiveVersion = appVersion
    destinationDirectory = file("${buildDir}/distributions")
    
    from("${buildDir}/distributions/${appName}") {
        into appName
    }
    
    doLast {
        println "✅ ZIP-Archiv erstellt: ${archiveFile.get().asFile.absolutePath}"
        println "   Entpacken Sie das ZIP und führen Sie ${appName}.exe aus dem ${appName}-Ordner aus."
    }
}

// Task zum Erstellen eines .msi oder .exe Installers für Windows (benötigt WiX)
task buildExeWiX(type: Exec) {
    group = 'distribution'
    description = 'Erstellt einen .msi Installer für Windows (benötigt WiX Toolset)'
    
    dependsOn shadowJar, convertIconToIco
    
    executable = 'jpackage'
    
    doFirst {
        // Prüfe ob wir auf Windows sind
        if (!System.getProperty('os.name').toLowerCase().contains('windows')) {
            throw new GradleException('buildExeWiX kann nur auf Windows ausgeführt werden.')
        }
        
        // Prüfe ob WiX verfügbar ist
        try {
            project.exec {
                commandLine 'light.exe', '-?'
                ignoreExitValue = true
            }
        } catch (Exception e) {
            throw new GradleException('WiX Toolset nicht gefunden!\n' +
                'Bitte installieren Sie WiX 3.0 oder später von https://wixtoolset.org/\n' +
                'und fügen Sie es zum PATH hinzu.\n' +
                'Alternativ verwenden Sie "gradlew buildExe" für ein ZIP-Archiv (kein WiX benötigt).\n' +
                'Das ZIP-Archiv kann einfach entpackt und die .exe direkt ausgeführt werden.')
        }
        
        // Lösche vorherige Builds
        delete fileTree("${buildDir}/distributions") {
            include "*.msi"
            include "*.exe"
        }
        
        def mainJar = shadowJar.archiveFileName.get()
        
        // Nur Icon verwenden, wenn es existiert und nicht leer ist (echtes ICO)
        def argsList = [
            '--input', "${buildDir}/libs",
            '--name', appName,
            '--main-jar', mainJar,
            '--main-class', mainClass,
            '--app-version', appVersion,
            '--vendor', vendor,
            '--dest', "${buildDir}/distributions",
            '--type', 'msi',
            '--win-dir-chooser',
            '--win-menu',
            '--win-shortcut',
            '--java-options', '--add-opens=java.base/java.lang=ALL-UNNAMED',
            '--java-options', '--add-opens=java.base/java.util=ALL-UNNAMED',
            '--arguments', 'client'
        ]
        
        // Füge Icon nur hinzu, wenn es ein gültiges ICO ist (nicht leer)
        if (iconIco.exists() && iconIco.length() > 0) {
            argsList.addAll(['--icon', iconIco.absolutePath])
        } else if (iconPng.exists()) {
            // Fallback: Versuche PNG (jpackage kann es manchmal akzeptieren)
            println "⚠️  Verwende PNG als Icon (ICO-Konvertierung fehlgeschlagen)"
            argsList.addAll(['--icon', iconPng.absolutePath])
        }
        
        args = argsList
    }
    
    doLast {
        println "✅ .msi Installer erstellt in: ${buildDir}/distributions/"
    }
}

// Task zum Erstellen beider Installer (nur auf macOS möglich)
task buildAllInstallers {
    group = 'distribution'
    description = 'Erstellt alle verfügbaren Installer'
    dependsOn buildDmg
    
    doLast {
        println "⚠️  Hinweis: Windows-Installer können nur auf Windows erstellt werden."
        println "   Für Windows-Installer bitte 'gradlew buildExe' auf einem Windows-System ausführen."
        println "   (Erstellt einen .msi Installer - kein WiX benötigt)"
    }
}